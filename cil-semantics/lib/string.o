#pragma KCIL_TU "__cstdlib__string__"
/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

typedef unsigned long size_t;
size_t strlen(char const   *str ) ;
int strcmp(char const   *s1 , char const   *s2 ) ;
extern char *strcpy(char *s1 , char const   *s2 ) ;
char *strncpy(char * __restrict  dest , char const   * __restrict  src , size_t n ) ;
char *strcat(char * __restrict  s1 , char const   * __restrict  s2 ) ;
char *strncat(char * __restrict  s1 , char const   * __restrict  s2 , size_t n ) ;
char *strchr(char const   *s , int c ) ;
void *memset(void *dest , int value , size_t len ) ;
void *memcpy(void *dest , void const   *src , size_t count ) ;
void *memmove(void *s1 , void const   *s2 , size_t n ) ;
int memcmp(void const   *s1 , void const   *s2 , size_t n ) ;
void *memchr(void const   *s , int c , size_t n ) ;
char *strrchr(char const   *s , int c ) ;
int strncmp(char const   *s1 , char const   *s2 , size_t n ) ;
size_t strcspn(char const   *s1 , char const   *s2 ) ;
char *strpbrk(char const   *s1 , char const   *s2 ) ;
size_t strspn(char const   *s1 , char const   *s2 ) ;
char *strstr(char const   *haystack , char const   *needle ) ;
char *strtok(char * __restrict  s1 , char const   * __restrict  delimiters ) ;
extern void *malloc(size_t size ) ;
extern void free(void *pointer ) ;
char *strncpy(char * __restrict  dest , char const   * __restrict  src , size_t n ) 
{ char *ret ;
  size_t tmp ;
  char * __restrict  tmp___0 ;
  char tmp___1 ;
  char const   * __restrict  tmp___2 ;
  char * __restrict  tmp___3 ;
  size_t tmp___4 ;

  {
  ret = (char *)dest;
  while (1) {
    tmp = n;
    n = n - 1UL;
    if (tmp) {

    } else {
      return (ret);
    }
    tmp___0 = dest;
    dest = dest + 1;
    tmp___2 = src;
    src = src + 1;
    tmp___1 = (char )*tmp___2;
    *tmp___0 = tmp___1;
    if (tmp___1) {

    } else {
      break;
    }
  }
  while (1) {
    tmp___4 = n;
    n = n - 1UL;
    if (tmp___4) {

    } else {
      break;
    }
    tmp___3 = dest;
    dest = dest + 1;
    *tmp___3 = (char)0;
  }
  return (ret);
}
}
size_t strlen(char const   *str ) 
{ char const   *s ;

  {
  s = str;
  while (1) {
    if (*s) {

    } else {
      break;
    }
    s = s + 1;
  }
  return ((unsigned long )(s - str));
}
}
void *memset(void *dest , int value , size_t len ) 
{ unsigned char *ptr ;
  unsigned char *tmp ;
  size_t tmp___0 ;

  {
  ptr = (unsigned char *)dest;
  while (1) {
    tmp___0 = len;
    len = len - 1UL;
    if (tmp___0 > 0UL) {

    } else {
      break;
    }
    tmp = ptr;
    ptr = ptr + 1;
    *tmp = (unsigned char )value;
  }
  return (dest);
}
}
void *memchr(void const   *s , int c , size_t n ) 
{ unsigned char const   *src ;
  unsigned char uc ;
  size_t tmp ;

  {
  src = (unsigned char const   *)s;
  uc = (unsigned char )c;
  while (1) {
    tmp = n;
    n = n - 1UL;
    if (tmp != 0UL) {

    } else {
      break;
    }
    if ((int const   )*src == (int const   )uc) {
      return ((void *)src);
    } else {

    }
    src = src + 1;
  }
  return ((void *)0);
}
}
size_t strcspn(char const   *s1 , char const   *s2 ) 
{ char const   *sc1 ;
  char *tmp ;

  {
  sc1 = s1;
  while (1) {
    if ((int const   )*sc1 != 0) {

    } else {
      break;
    }
    tmp = strchr(s2, (int )*sc1);
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
      return ((unsigned long )(sc1 - s1));
    } else {

    }
    sc1 = sc1 + 1;
  }
  return ((unsigned long )(sc1 - s1));
}
}
char *strpbrk(char const   *s1 , char const   *s2 ) 
{ char const   *sc1 ;
  char *tmp ;

  {
  sc1 = s1;
  while (1) {
    if ((int const   )*sc1 != 0) {

    } else {
      break;
    }
    tmp = strchr(s2, (int )*sc1);
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
      return ((char *)sc1);
    } else {

    }
    sc1 = sc1 + 1;
  }
  return ((char *)((void *)0));
}
}
size_t strspn(char const   *s1 , char const   *s2 ) 
{ char const   *sc1 ;
  char *tmp ;

  {
  sc1 = s1;
  while (1) {
    if ((int const   )*sc1 != 0) {

    } else {
      break;
    }
    tmp = strchr(s2, (int )*sc1);
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      return ((unsigned long )(sc1 - s1));
    } else {

    }
    sc1 = sc1 + 1;
  }
  return ((unsigned long )(sc1 - s1));
}
}
char *strstr(char const   *haystack , char const   *needle ) 
{ size_t needlelen ;
  int tmp ;
  char *tmp___0 ;

  {
  if ((int const   )*needle == 0) {
    return ((char *)haystack);
  } else {

  }
  needlelen = strlen(needle);
  while (1) {
    tmp___0 = strchr(haystack, (int )*needle);
    haystack = (char const   *)tmp___0;
    if ((unsigned long )haystack != (unsigned long )((void *)0)) {

    } else {
      break;
    }
    tmp = strncmp(haystack, needle, needlelen);
    if (tmp == 0) {
      return ((char *)haystack);
    } else {

    }
    haystack = haystack + 1;
  }
  return ((char *)((void *)0));
}
}
char *strtok_r(char *s , char const   *delimiters , char **lasts ) 
{ char *sbegin ;
  char *send ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;

  {
  if (s) {
    sbegin = s;
  } else {
    sbegin = *lasts;
  }
  tmp = strspn((char const   *)sbegin, delimiters);
  sbegin = sbegin + tmp;
  if ((int )*sbegin == 0) {
    *lasts = (char *)"";
    return ((char *)((void *)0));
  } else {

  }
  tmp___0 = strcspn((char const   *)sbegin, delimiters);
  send = sbegin + tmp___0;
  if ((int )*send != 0) {
    tmp___1 = send;
    send = send + 1;
    *tmp___1 = (char )'\000';
  } else {

  }
  *lasts = send;
  return (sbegin);
}
}
char *strtok(char * __restrict  s1 , char const   * __restrict  delimiters ) ;
static char *ssave  =    (char *)"";
char *strtok(char * __restrict  s1 , char const   * __restrict  delimiters ) 
{ char *tmp ;

  {
  tmp = strtok_r((char *)s1, (char const   *)delimiters, & ssave);
  return (tmp);
}
}
int strcmp(char const   *s1 , char const   *s2 ) 
{ int tmp ;

  {
  while (1) {
    if ((int const   )*s1 == (int const   )*s2) {

    } else {
      break;
    }
    if ((int const   )*s1 == 0) {
      return (0);
    } else {

    }
    s1 = s1 + 1;
    s2 = s2 + 1;
  }
  if ((int )*((unsigned char *)s1) < (int )*((unsigned char *)s2)) {
    tmp = -1;
  } else {
    tmp = 1;
  }
  return (tmp);
}
}
void *memmove(void *s1 , void const   *s2 , size_t n ) 
{ char *tmp ;
  void *tmp___0 ;

  {
  tmp___0 = malloc(n);
  tmp = (char *)tmp___0;
  memcpy((void *)tmp, s2, n);
  memcpy(s1, (void const   *)tmp, n);
  free((void *)tmp);
  return (s1);
}
}
char *strchr(char const   *s , int c ) 
{ char *tmp ;

  {
  while (1) {
    if ((int const   )*s != 0) {
      if ((int const   )*s != (int const   )((char )c)) {

      } else {
        break;
      }
    } else {
      break;
    }
    s = s + 1;
  }
  if ((int const   )*s == (int const   )c) {
    tmp = (char *)s;
  } else {
    tmp = (char *)((void *)0);
  }
  return (tmp);
}
}
int strncmp(char const   *s1 , char const   *s2 , size_t n ) 
{ unsigned char uc1 ;
  unsigned char uc2 ;
  size_t tmp ;
  int tmp___0 ;

  {
  if (n == 0UL) {
    return (0);
  } else {

  }
  while (1) {
    tmp = n;
    n = n - 1UL;
    if (tmp > 0UL) {
      if ((int const   )*s1 == (int const   )*s2) {

      } else {
        break;
      }
    } else {
      break;
    }
    if (n == 0UL) {
      return (0);
    } else {
      if ((int const   )*s1 == 0) {
        return (0);
      } else {

      }
    }
    s1 = s1 + 1;
    s2 = s2 + 1;
  }
  uc1 = *((unsigned char *)s1);
  uc2 = *((unsigned char *)s2);
  if ((int )uc1 < (int )uc2) {
    tmp___0 = -1;
  } else {
    tmp___0 = (int )uc1 > (int )uc2;
  }
  return (tmp___0);
}
}
char *strrchr(char const   *s , int c ) 
{ char const   *last ;
  char *tmp ;
  char *tmp___0 ;

  {
  last = (char const   *)((void *)0);
  if (c == 0) {
    tmp = strchr(s, c);
    return (tmp);
  } else {

  }
  while (1) {
    tmp___0 = strchr(s, c);
    s = (char const   *)tmp___0;
    if ((unsigned long )s != (unsigned long )((void *)0)) {

    } else {
      break;
    }
    last = s;
    s = s + 1;
  }
  return ((char *)last);
}
}
void *memcpy(void *dest , void const   *src , size_t count ) 
{ char *dst8 ;
  char *src8 ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;

  {
  dst8 = (char *)dest;
  src8 = (char *)src;
  while (1) {
    tmp___1 = count;
    count = count - 1UL;
    if (tmp___1) {

    } else {
      break;
    }
    tmp = dst8;
    dst8 = dst8 + 1;
    tmp___0 = src8;
    src8 = src8 + 1;
    *tmp = *tmp___0;
  }
  return (dest);
}
}
int memcmp(void const   *s1 , void const   *s2 , size_t n ) 
{ unsigned char const   *us1 ;
  unsigned char const   *us2 ;
  int tmp ;
  size_t tmp___0 ;

  {
  us1 = (unsigned char const   *)s1;
  us2 = (unsigned char const   *)s2;
  while (1) {
    tmp___0 = n;
    n = n - 1UL;
    if (tmp___0 != 0UL) {

    } else {
      break;
    }
    if ((int const   )*us1 != (int const   )*us2) {
      if ((int const   )*us1 < (int const   )*us2) {
        tmp = -1;
      } else {
        tmp = 1;
      }
      return (tmp);
    } else {

    }
    us1 = us1 + 1;
    us2 = us2 + 1;
  }
  return (0);
}
}
char *strcat(char * __restrict  s1 , char const   * __restrict  s2 ) 
{ char *s ;

  {
  s = (char *)s1;
  while (1) {
    if ((int )*s != 0) {

    } else {
      break;
    }
    s = s + 1;
  }
  strcpy(s, (char const   *)s2);
  return ((char *)s1);
}
}
char *strncat(char * __restrict  s1 , char const   * __restrict  s2 , size_t n ) 
{ char *s ;
  char tmp ;
  char const   * __restrict  tmp___0 ;

  {
  s = (char *)s1;
  while (1) {
    if ((int )*s != 0) {

    } else {
      break;
    }
    s = s + 1;
  }
  while (1) {
    if (n != 0UL) {
      tmp___0 = s2;
      s2 = s2 + 1;
      tmp = (char )*tmp___0;
      *s = tmp;
      if ((int )tmp != 0) {

      } else {
        break;
      }
    } else {
      break;
    }
    n = n - 1UL;
    s = s + 1;
  }
  *s = (char )'\000';
  return ((char *)s1);
}
}
