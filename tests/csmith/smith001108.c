/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.0.0
 * svn version: exported
 * Options:   --check-global -s 1108
 * Seed:      1108
 */

#include "random_runtime.h"


long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
 volatile int8_t g_7[6] = {0xD7L, 0xD7L, 0xD7L, 0xD7L, 0xD7L, 0xD7L};
int32_t g_12 = 0x49AAED6BL;
int32_t *g_11 = &g_12;
int32_t g_32 = 0xB0866193L;
int32_t g_42 = 0x4B05EF13L;
int32_t ** volatile g_46 = &g_11;/* VOLATILE GLOBAL g_46 */


/* --- FORWARD DECLARATIONS --- */
uint32_t  func_1(void);
int32_t  func_8(uint32_t  p_9,  const int32_t  p_10);
int32_t  func_22( const int32_t * p_23,  const uint32_t  p_24, int64_t  p_25, int32_t  p_26, uint32_t  p_27);
 const int32_t  func_38(uint16_t  p_39, uint32_t  p_40);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_7 g_11 g_12 g_32 g_42 g_46
 * writes: g_11 g_32 g_12
 */
uint32_t  func_1(void)
{ /* block id: 0 */
    int8_t l_2 = 0x8DL;
    int32_t *l_44 = &g_32;
    int i;
    (*l_44) = ((l_2 & (safe_rshift_func_int8_t_s_u(l_2, 0L))) > (safe_mod_func_int32_t_s_s(((((l_2 ^ g_7[2]) <= func_8(l_2, l_2)) | g_42) < l_2), l_2)));
    if (g_12)
        goto lbl_47;
lbl_47:
    for (g_12 = 0; g_12 < 6; g_12 += 2)
    { /* block id: 19 */
        int32_t *l_45 = &g_42;
        (*g_46) = l_45;
        (*l_44) &= (((g_7[(uint32_t)(g_12) % 6] == 0xF40BF68DL) < (*g_11)) >= (&l_44 != 0));
    }
    return g_42;
}


/* ------------------------------------------ */
/* 
 * reads : g_11 g_12 g_32
 * writes: g_11 g_32 g_12
 */
int32_t  func_8(uint32_t  p_9,  const int32_t  p_10)
{ /* block id: 1 */
    int32_t **l_13 = &g_11;
    uint16_t l_37 = 0x50FAL;
    (*l_13) = g_11;
    (**l_13) = (safe_mul_func_uint16_t_u_u((safe_rshift_func_int8_t_s_s((((*g_11) | (((**l_13) && (**l_13)) == ((*g_11) || (*g_11)))) == 0xA3D7F191L), 0L)), (safe_mod_func_int16_t_s_s((safe_div_func_uint64_t_u_u(p_10, (**l_13))), func_22((*l_13), (**l_13), g_32, l_37, (func_38((**l_13), (p_9 ^ (*g_11))) < (0xEB0BADCAL < (**l_13))))))));
    (*g_11) = -1L;
    return (*g_11);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_32
 */
int32_t  func_22( const int32_t * p_23,  const uint32_t  p_24, int64_t  p_25, int32_t  p_26, uint32_t  p_27)
{ /* block id: 3 */
    int64_t l_33 = 1L;
    int32_t **l_34 = 0;
    int32_t *l_36 = &g_32;
    int32_t **l_35 = &l_36;
    for (p_27 = 0; (p_27 != 0); p_27 = safe_sub_func_uint32_t_u_u(p_27, 1))
    { /* block id: 6 */
        int32_t *l_30 = &g_12;
        int32_t *l_31[6][9];
        int i, j;
        for (i = 0; i < 6; i++)
        {
            for (j = 0; j < 9; j++)
                l_31[i][j] = &g_32;
        }
        g_32 |= (0 != l_30);
    }
    p_26 |= l_33;
    (*l_35) = &p_26;
    return (**l_35);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
 const int32_t  func_38(uint16_t  p_39, uint32_t  p_40)
{ /* block id: 12 */
    int32_t *l_41 = &g_42;
     const int32_t l_43 = 0x601C8D53L;
    l_41 = 0;
    return l_43;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int i;
    func_1();
    printf("checksum g_7[0] = %d\n", g_7[0]);
    printf("checksum g_7[1] = %d\n", g_7[1]);
    printf("checksum g_7[2] = %d\n", g_7[2]);
    printf("checksum g_7[3] = %d\n", g_7[3]);
    printf("checksum g_7[4] = %d\n", g_7[4]);
    printf("checksum g_7[5] = %d\n", g_7[5]);
    printf("checksum g_7[2] = %d\n", g_7[2]);
    printf("checksum g_12 = %d\n", g_12);
    printf("checksum g_32 = %d\n", g_32);
    printf("checksum g_42 = %d\n", g_42);
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 19

XXX max expression depth: 0
breakdown:
   depth: 0, occurrence: 14

XXX total number of pointers: 12

XXX times a variable address is taken: 6
XXX times a pointer is dereferenced on RHS: 14
breakdown:
   depth: 1, occurrence: 7
   depth: 2, occurrence: 7
XXX times a pointer is dereferenced on LHS: 7
breakdown:
   depth: 1, occurrence: 6
   depth: 2, occurrence: 1
XXX times a pointer is compared with null: 2
XXX times a pointer is compared with address of another variable: 0
XXX times a pointer is compared with another pointer: 0
XXX times a pointer is qualified to be dereferenced: 36

XXX max dereference level: 2
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 24
   level: 2, occurrence: 11
XXX number of pointers point to pointers: 4
XXX number of pointers point to scalars: 8
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 16.7
XXX average alias set size: 1.17

XXX times a non-volatile is read: 55
XXX times a non-volatile is write: 18
XXX times a volatile is read: 2
XXX    times read thru a pointer: 0
XXX times a volatile is write: 1
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 1
XXX percentage of non-volatile access: 96.1

XXX forward jumps: 1
XXX backward jumps: 0

XXX stmts: 25

XXX percentage a fresh-made variable is used: 21.4
XXX percentage an existing variable is used: 78.6
********************* end of statistics **********************/

