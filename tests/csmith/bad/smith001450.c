/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.0.0
 * svn version: exported
 * Options:   --check-global -s 1450
 * Seed:      1450
 */

#include "random_runtime.h"


long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
 volatile int32_t g_2 = 0L;/* VOLATILE GLOBAL g_2 */
uint64_t g_10 = -1L;
int32_t g_13 = 0x3C0BF90AL;
int32_t g_24 = -1L;
uint64_t g_40[7] = {0x656540F213ED423CLL, 0x656540F213ED423CLL, 0x656540F213ED423CLL, 0x656540F213ED423CLL, 0x656540F213ED423CLL, 0x656540F213ED423CLL, 0x656540F213ED423CLL};
int16_t g_41[6] = {1L, 1L, 1L, 1L, 1L, 1L};


/* --- FORWARD DECLARATIONS --- */
uint64_t  func_1(void);
int32_t  func_5( const int8_t  p_6, uint64_t  p_7);
 const int32_t  func_28(uint64_t  p_29, int32_t * p_30);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_2 g_13 g_10 g_24 g_40
 * writes: g_2 g_13 g_24 g_41
 */
uint64_t  func_1(void)
{ /* block id: 0 */
    int32_t l_19 = 0L;
    int32_t *l_34 = &g_24;
    for (g_2 = -14; (g_2 <= 13); g_2 = safe_add_func_int64_t_s_s(g_2, 1))
    { /* block id: 3 */
        int64_t l_22 = -10L;
        int32_t *l_23 = &g_24;
        int32_t **l_25 = &l_23;
        uint32_t l_37 = 3L;
        if (g_2)
            break;
        (*l_23) &= (g_2 < func_5(0x47L, (safe_unary_minus_func_int16_t_s((safe_add_func_int16_t_s_s(((safe_sub_func_uint16_t_u_u(g_13, g_10)) && l_19), (safe_rshift_func_uint16_t_u_s(l_22, 1L))))))));
        (*l_25) = 0;
        g_41[5] |= (safe_mod_func_uint8_t_u_u(func_28((0L > (g_2 < (0L || (safe_sub_func_uint16_t_u_u(g_13, g_13))))), l_34), (+((safe_rshift_func_int8_t_s_u(((g_10 ^ l_37) < g_10), (safe_rshift_func_int16_t_s_u((g_10 && g_40[5]), -1L)))) || (g_40[3] && 0xC3B03C3FL)))));
    }
    (*l_34) = (-8L || (g_10 == (*l_34)));
    return (*l_34);
}


/* ------------------------------------------ */
/* 
 * reads : g_10 g_13
 * writes: g_13
 */
int32_t  func_5( const int8_t  p_6, uint64_t  p_7)
{ /* block id: 5 */
    uint32_t l_11 = 0x49CEC79EL;
    int32_t *l_12 = &g_13;
    for (p_7 = 0; (p_7 <= 0); p_7 = safe_add_func_int8_t_s_s(p_7, 1))
    { /* block id: 8 */
        return g_10;
    }
    (*l_12) |= l_11;
    return (*l_12);
}


/* ------------------------------------------ */
/* 
 * reads : g_10 g_13 g_24
 * writes: g_13 g_24
 */
 const int32_t  func_28(uint64_t  p_29, int32_t * p_30)
{ /* block id: 15 */
     const uint32_t l_31 = -8L;
    (*p_30) = (func_5(p_29, g_10) ^ (*p_30));
    return l_31;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int i;
    func_1();
    printf("checksum g_2 = %d\n", g_2);
    printf("checksum g_10 = %d\n", g_10);
    printf("checksum g_13 = %d\n", g_13);
    printf("checksum g_24 = %d\n", g_24);
    printf("checksum g_40[0] = %d\n", g_40[0]);
    printf("checksum g_40[1] = %d\n", g_40[1]);
    printf("checksum g_40[2] = %d\n", g_40[2]);
    printf("checksum g_40[3] = %d\n", g_40[3]);
    printf("checksum g_40[4] = %d\n", g_40[4]);
    printf("checksum g_40[5] = %d\n", g_40[5]);
    printf("checksum g_40[6] = %d\n", g_40[6]);
    printf("checksum g_40[5] = %d\n", g_40[5]);
    printf("checksum g_41[0] = %d\n", g_41[0]);
    printf("checksum g_41[1] = %d\n", g_41[1]);
    printf("checksum g_41[2] = %d\n", g_41[2]);
    printf("checksum g_41[3] = %d\n", g_41[3]);
    printf("checksum g_41[4] = %d\n", g_41[4]);
    printf("checksum g_41[5] = %d\n", g_41[5]);
    printf("checksum g_41[5] = %d\n", g_41[5]);
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 15

XXX max expression depth: 0
breakdown:
   depth: 0, occurrence: 10

XXX total number of pointers: 5

XXX times a variable address is taken: 2
XXX times a pointer is dereferenced on RHS: 4
breakdown:
   depth: 1, occurrence: 4
XXX times a pointer is dereferenced on LHS: 5
breakdown:
   depth: 1, occurrence: 5
XXX times a pointer is compared with null: 0
XXX times a pointer is compared with address of another variable: 0
XXX times a pointer is compared with another pointer: 0
XXX times a pointer is qualified to be dereferenced: 13

XXX max dereference level: 2
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 21
   level: 2, occurrence: 2
XXX number of pointers point to pointers: 1
XXX number of pointers point to scalars: 4
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 20
XXX average alias set size: 1.2

XXX times a non-volatile is read: 28
XXX times a non-volatile is write: 12
XXX times a volatile is read: 4
XXX    times read thru a pointer: 0
XXX times a volatile is write: 1
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 5
XXX percentage of non-volatile access: 88.9

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 22

XXX percentage a fresh-made variable is used: 29
XXX percentage an existing variable is used: 71
********************* end of statistics **********************/

