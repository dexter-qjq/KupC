/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.0.0
 * svn version: exported
 * Options:   --check-global -s 1625
 * Seed:      1625
 */

#include "random_runtime.h"


long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
uint8_t g_4 = 0x5BL;
 volatile int32_t g_7 = 1L;/* VOLATILE GLOBAL g_7 */
 volatile int32_t *g_6 = &g_7;
uint32_t g_18 = -1L;
 const int16_t g_38 = 1L;
uint32_t g_39[4][2] = {{6L, 6L}, {6L, 6L}, {6L, 6L}, {6L, 6L}};


/* --- FORWARD DECLARATIONS --- */
int32_t  func_1(void);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_6 g_7 g_18 g_38 g_4 g_39
 * writes: g_4 g_6 g_7 g_18 g_39
 */
int32_t  func_1(void)
{ /* block id: 0 */
     const int8_t l_2[7] = {1L, 1L, 1L, 1L, 1L, 1L, 1L};
    int32_t *l_3[3];
    uint64_t l_5 = 0x4F2887CF2E5664DCLL;
    int i;
    for (i = 0; i < 3; i++)
        l_3[i] = 0;
    g_4 = l_2[5];
    if (l_5)
    { /* block id: 2 */
         volatile int32_t **l_8 = &g_6;
        (*l_8) = g_6;
        for (g_4 = 27; (g_4 == 0); g_4 = safe_sub_func_int16_t_s_s(g_4, 1))
        { /* block id: 6 */
            return g_7;
        }
        for (g_7 = 25; (g_7 < 14); g_7 = safe_add_func_int8_t_s_s(g_7, 8))
        { /* block id: 11 */
            int8_t l_15 = 0xB8L;
            int32_t l_20 = 0x9F08664AL;
            if ((**l_8))
                break;
            for (l_5 = 0; (l_5 <= -30); l_5 = safe_sub_func_int64_t_s_s(l_5, 1))
            { /* block id: 15 */
                uint32_t l_19 = 1L;
                (*g_6) = l_15;
                g_18 ^= (safe_add_func_uint16_t_u_u((*g_6), 1L));
                if (l_19)
                    continue;
            }
            return l_20;
        }
    }
    else
    { /* block id: 22 */
        int8_t l_21[3][10][1][2][1];
        int i, j, k, l, m;
        for (i = 0; i < 3; i++)
        {
            for (j = 0; j < 10; j++)
            {
                for (k = 0; k < 1; k++)
                {
                    for (l = 0; l < 2; l++)
                    {
                        for (m = 0; m < 1; m++)
                            l_21[i][j][k][l][m] = 0x62L;
                    }
                }
            }
        }
        return l_21[0][2][0][0][0];
    }
    g_6 = &g_7;
    for (g_18 = 0; (g_18 < 0); g_18 = safe_sub_func_uint8_t_u_u(g_18, 3))
    { /* block id: 28 */
        uint8_t l_26 = 6L;
        int32_t l_27 = 0xDA972737L;
        for (l_5 = -1; (l_5 > 22); l_5 = safe_add_func_uint32_t_u_u(l_5, 5))
        { /* block id: 31 */
            return l_26;
        }
        l_27 ^= (*g_6);
        g_39[0][1] ^= (safe_mod_func_uint8_t_u_u((safe_sub_func_int8_t_s_s((safe_rshift_func_uint16_t_u_s(0x7276CC72L, (((*g_6) | g_18) && (safe_rshift_func_uint8_t_u_u((*g_6), 7L))))), ((l_3[1] == l_3[1]) & g_18))), (0x5015E0C0L < (~(((safe_rshift_func_uint8_t_u_u(l_26, l_26)) ^ (l_27 != g_38)) < (1L >= (g_4 || l_27)))))));
    }
    return g_39[2][1];
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int i, j;
    func_1();
    printf("checksum g_4 = %d\n", g_4);
    printf("checksum g_7 = %d\n", g_7);
    printf("checksum g_18 = %d\n", g_18);
    printf("checksum g_38 = %d\n", g_38);
    printf("checksum g_39[0][0] = %d\n", g_39[0][0]);
    printf("checksum g_39[0][1] = %d\n", g_39[0][1]);
    printf("checksum g_39[1][0] = %d\n", g_39[1][0]);
    printf("checksum g_39[1][1] = %d\n", g_39[1][1]);
    printf("checksum g_39[2][0] = %d\n", g_39[2][0]);
    printf("checksum g_39[2][1] = %d\n", g_39[2][1]);
    printf("checksum g_39[3][0] = %d\n", g_39[3][0]);
    printf("checksum g_39[3][1] = %d\n", g_39[3][1]);
    printf("checksum g_39[0][1] = %d\n", g_39[0][1]);
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 16

XXX max expression depth: 0
breakdown:
   depth: 0, occurrence: 13

XXX total number of pointers: 3

XXX times a variable address is taken: 2
XXX times a pointer is dereferenced on RHS: 5
breakdown:
   depth: 1, occurrence: 4
   depth: 2, occurrence: 1
XXX times a pointer is dereferenced on LHS: 2
breakdown:
   depth: 1, occurrence: 2
XXX times a pointer is compared with null: 0
XXX times a pointer is compared with address of another variable: 0
XXX times a pointer is compared with another pointer: 1
XXX times a pointer is qualified to be dereferenced: 41

XXX max dereference level: 2
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 8
   level: 2, occurrence: 1
XXX number of pointers point to pointers: 1
XXX number of pointers point to scalars: 2
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 33.3
XXX average alias set size: 1

XXX times a non-volatile is read: 29
XXX times a non-volatile is write: 12
XXX times a volatile is read: 7
XXX    times read thru a pointer: 5
XXX times a volatile is write: 2
XXX    times written thru a pointer: 1
XXX times a volatile is available for access: 13
XXX percentage of non-volatile access: 82

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 38

XXX percentage a fresh-made variable is used: 31
XXX percentage an existing variable is used: 69
********************* end of statistics **********************/

